# Complete CI/CD Pipeline: Test â†’ Build â†’ Push to ACR â†’ Deploy
trigger:
- main
- master

pool:
  vmImage: 'ubuntu-latest'

variables:
  buildConfiguration: 'Release'
  webAppName: 'calendar-app-dhanshrepriya'
  resourceGroupName: 'QA_Deployments'
  location: 'Central India'
  
  # ACR Configuration
  containerRegistry: 'acrqamicroservices.azurecr.io'
  imageRepository: 'calendar-app'
  dockerfilePath: '$(Build.SourcesDirectory)/Dockerfile'
  imageTag: 'v1.0-$(Build.BuildId)'
  
  # Test thresholds
  minPassRate: 90

stages:
- stage: Test
  displayName: 'Run Tests & Quality Gates'
  jobs:
    - job: ReactTests
      displayName: 'React Tests'
      steps:
        - task: NodeTool@0
          inputs:
            versionSpec: '20.x'
          displayName: 'Setup Node.js 20'

        - script: |
            cd react-app-template
            npm ci
            export TZ=UTC
            
            # Run tests and capture results
            npm test -- --watchAll=false --verbose --passWithNoTests --json --outputFile=test-results.json || true
            
            # Parse test results
            if [ -f test-results.json ]; then
              TOTAL_TESTS=$(cat test-results.json | jq -r '.numTotalTests // 0')
              PASSED_TESTS=$(cat test-results.json | jq -r '.numPassedTests // 0')
              FAILED_TESTS=$(cat test-results.json | jq -r '.numFailedTests // 0')
            else
              echo "âŒ No test results file found - failing pipeline"
              exit 1
            fi
            
            # Validate parsed values
            if [ -z "$TOTAL_TESTS" ] || [ "$TOTAL_TESTS" = "0" ]; then
              echo "âŒ Failed to parse test results"
              exit 1
            fi
            
            # Calculate pass rate
            if [ "$TOTAL_TESTS" -gt 0 ]; then
              PASS_RATE=$(echo "scale=2; $PASSED_TESTS * 100 / $TOTAL_TESTS" | bc -l)
            else
              PASS_RATE=0
            fi
            
            echo "=== REACT TEST RESULTS ==="
            echo "Total Tests: $TOTAL_TESTS"
            echo "Passed: $PASSED_TESTS"
            echo "Failed: $FAILED_TESTS"
            echo "Pass Rate: ${PASS_RATE}%"
            
            # Export variables for later stages
            echo "##vso[task.setvariable variable=reactTotal;isOutput=true]$TOTAL_TESTS"
            echo "##vso[task.setvariable variable=reactPassed;isOutput=true]$PASSED_TESTS"
            echo "##vso[task.setvariable variable=reactFailed;isOutput=true]$FAILED_TESTS"
            echo "##vso[task.setvariable variable=reactPassRate;isOutput=true]$PASS_RATE"
          name: reactResults
          displayName: 'Run React Tests & Calculate Results'
          env:
            CI: true
            TZ: UTC

    - job: DotNetTests
      displayName: '.NET Tests'
      steps:
        - task: UseDotNet@2
          inputs:
            packageType: 'sdk'
            version: '7.x'
          displayName: 'Setup .NET 7'

        - script: |
            cd DisprzTraining
            dotnet restore
            dotnet build --configuration Release --no-restore
            
            echo "=== RUNNING .NET 7 TESTS ==="
            
            # Run tests with detailed console output and capture to file
            dotnet test --configuration Release --no-build \
              --logger "console;verbosity=detailed" \
              --results-directory TestResults \
              > test_output.log 2>&1
            
            TEST_EXIT_CODE=$?
            
            # Display the test output
            echo "=== TEST OUTPUT ==="
            cat test_output.log
            echo "=== END TEST OUTPUT ==="
            
            # Parse from console output using multiple patterns
            echo "=== PARSING TEST RESULTS ==="
            
            # Method 1: Standard dotnet test output patterns
            TOTAL_TESTS=$(grep -oE "Total tests: [0-9]+" test_output.log | grep -oE "[0-9]+" | tail -1)
            PASSED_TESTS=$(grep -oE "Passed: [0-9]+" test_output.log | grep -oE "[0-9]+" | tail -1)
            FAILED_TESTS=$(grep -oE "Failed: [0-9]+" test_output.log | grep -oE "[0-9]+" | tail -1)
            SKIPPED_TESTS=$(grep -oE "Skipped: [0-9]+" test_output.log | grep -oE "[0-9]+" | tail -1)
            
            # Method 2: Alternative patterns if first method fails
            if [ -z "$TOTAL_TESTS" ]; then
              echo "Trying alternative parsing patterns..."
              TOTAL_TESTS=$(grep -oE "Total: [0-9]+" test_output.log | grep -oE "[0-9]+" | tail -1)
              PASSED_TESTS=$(grep -oE "Passed - [0-9]+" test_output.log | grep -oE "[0-9]+" | tail -1)
              FAILED_TESTS=$(grep -oE "Failed - [0-9]+" test_output.log | grep -oE "[0-9]+" | tail -1)
            fi
            
            # Method 3: Parse from test summary line
            if [ -z "$TOTAL_TESTS" ]; then
              echo "Trying test summary parsing..."
              # Look for patterns like "Test Run Successful. Total tests: 301 Passed: 292 Failed: 9"
              SUMMARY_LINE=$(grep -E "(Test Run|Total tests)" test_output.log | tail -1)
              if [ -n "$SUMMARY_LINE" ]; then
                echo "Found summary line: $SUMMARY_LINE"
                TOTAL_TESTS=$(echo "$SUMMARY_LINE" | grep -oE "Total tests: [0-9]+" | grep -oE "[0-9]+")
                PASSED_TESTS=$(echo "$SUMMARY_LINE" | grep -oE "Passed: [0-9]+" | grep -oE "[0-9]+")
                FAILED_TESTS=$(echo "$SUMMARY_LINE" | grep -oE "Failed: [0-9]+" | grep -oE "[0-9]+")
              fi
            fi
            
            # Method 4: Count individual test results if summary parsing fails
            if [ -z "$TOTAL_TESTS" ]; then
              echo "Counting individual test results..."
              PASSED_TESTS=$(grep -c "PASSED" test_output.log || echo "0")
              FAILED_TESTS=$(grep -c "FAILED" test_output.log || echo "0")
              TOTAL_TESTS=$((PASSED_TESTS + FAILED_TESTS))
            fi
            
            # Set defaults for empty values
            TOTAL_TESTS=${TOTAL_TESTS:-0}
            PASSED_TESTS=${PASSED_TESTS:-0}
            FAILED_TESTS=${FAILED_TESTS:-0}
            SKIPPED_TESTS=${SKIPPED_TESTS:-0}
            
            # Validate and calculate missing values
            if [ "$TOTAL_TESTS" -eq 0 ] && [ "$PASSED_TESTS" -gt 0 ]; then
              TOTAL_TESTS=$((PASSED_TESTS + FAILED_TESTS + SKIPPED_TESTS))
            fi
            
            if [ "$FAILED_TESTS" -eq 0 ] && [ "$TOTAL_TESTS" -gt "$PASSED_TESTS" ]; then
              FAILED_TESTS=$((TOTAL_TESTS - PASSED_TESTS - SKIPPED_TESTS))
            fi
            
            # Final validation
            if [ "$TOTAL_TESTS" -eq 0 ]; then
              echo "âŒ Could not parse any test results from output"
              echo "=== FULL OUTPUT FOR DEBUGGING ==="
              cat test_output.log
              echo "=== END FULL OUTPUT ==="
              exit 1
            fi
            
            # Calculate pass rate
            if [ "$TOTAL_TESTS" -gt 0 ]; then
              PASS_RATE=$(echo "scale=2; $PASSED_TESTS * 100 / $TOTAL_TESTS" | bc -l)
            else
              PASS_RATE=0
            fi
            
            echo "=== .NET 7 TEST RESULTS ==="
            echo "Total Tests: $TOTAL_TESTS"
            echo "Passed: $PASSED_TESTS"
            echo "Failed: $FAILED_TESTS"
            echo "Skipped: $SKIPPED_TESTS"
            echo "Pass Rate: ${PASS_RATE}%"
            echo "Test Exit Code: $TEST_EXIT_CODE"
            
            # Export variables
            echo "##vso[task.setvariable variable=dotnetTotal;isOutput=true]$TOTAL_TESTS"
            echo "##vso[task.setvariable variable=dotnetPassed;isOutput=true]$PASSED_TESTS"
            echo "##vso[task.setvariable variable=dotnetFailed;isOutput=true]$FAILED_TESTS"
            echo "##vso[task.setvariable variable=dotnetPassRate;isOutput=true]$PASS_RATE"
          name: dotnetResults
          displayName: 'Run .NET 7 Tests & Calculate Results'
          env:
            TZ: UTC
            DOTNET_SYSTEM_GLOBALIZATION_INVARIANT: true

    - job: TestEvaluation
      displayName: 'Quality Gate Evaluation'
      dependsOn: [ReactTests, DotNetTests]
      condition: always()
      variables:
        reactTotal: $[ dependencies.ReactTests.outputs['reactResults.reactTotal'] ]
        reactPassed: $[ dependencies.ReactTests.outputs['reactResults.reactPassed'] ]
        reactFailed: $[ dependencies.ReactTests.outputs['reactResults.reactFailed'] ]
        reactPassRate: $[ dependencies.ReactTests.outputs['reactResults.reactPassRate'] ]
        dotnetTotal: $[ dependencies.DotNetTests.outputs['dotnetResults.dotnetTotal'] ]
        dotnetPassed: $[ dependencies.DotNetTests.outputs['dotnetResults.dotnetPassed'] ]
        dotnetFailed: $[ dependencies.DotNetTests.outputs['dotnetResults.dotnetFailed'] ]
        dotnetPassRate: $[ dependencies.DotNetTests.outputs['dotnetResults.dotnetPassRate'] ]
      steps:
        - script: |
            echo "=== QUALITY GATE EVALUATION ==="
            echo ""
            echo "ðŸ“Š REACT TEST RESULTS:"
            echo "   Total: $(reactTotal)"
            echo "   Passed: $(reactPassed)"
            echo "   Failed: $(reactFailed)"
            echo "   Pass Rate: $(reactPassRate)%"
            echo ""
            echo "ðŸ“Š .NET 7 TEST RESULTS:"
            echo "   Total: $(dotnetTotal)"
            echo "   Passed: $(dotnetPassed)"
            echo "   Failed: $(dotnetFailed)"
            echo "   Pass Rate: $(dotnetPassRate)%"
            echo ""
            
            # Calculate combined results
            TOTAL_ALL=$(($(reactTotal) + $(dotnetTotal)))
            PASSED_ALL=$(($(reactPassed) + $(dotnetPassed)))
            FAILED_ALL=$(($(reactFailed) + $(dotnetFailed)))
            
            if [ "$TOTAL_ALL" -gt 0 ]; then
              COMBINED_PASS_RATE=$(echo "scale=2; $PASSED_ALL * 100 / $TOTAL_ALL" | bc -l)
            else
              COMBINED_PASS_RATE=0
            fi
            
            echo "ðŸ“Š COMBINED RESULTS:"
            echo "   Total Tests: $TOTAL_ALL"
            echo "   Passed: $PASSED_ALL"
            echo "   Failed: $FAILED_ALL"
            echo "   Combined Pass Rate: ${COMBINED_PASS_RATE}%"
            echo ""
            echo "ðŸŽ¯ QUALITY GATE THRESHOLD: $(minPassRate)%"
            echo ""
            
            # Evaluate quality gate
            PASS_GATE=$(echo "$COMBINED_PASS_RATE >= $(minPassRate)" | bc -l)
            
            if [ "$PASS_GATE" -eq 1 ]; then
              echo "âœ… QUALITY GATE PASSED!"
              echo "   Combined pass rate (${COMBINED_PASS_RATE}%) exceeds threshold ($(minPassRate)%)"
              echo "   ðŸš€ PROCEEDING TO BUILD & DEPLOY"
              echo "##vso[task.setvariable variable=shouldDeploy;isOutput=true]true"
              echo "##vso[task.setvariable variable=qualityGateStatus;isOutput=true]PASSED"
            else
              echo "âŒ QUALITY GATE FAILED!"
              echo "   Combined pass rate (${COMBINED_PASS_RATE}%) below threshold ($(minPassRate)%)"
              echo "   ðŸ›‘ BLOCKING BUILD & DEPLOY"
              echo "##vso[task.setvariable variable=shouldDeploy;isOutput=true]false"
              echo "##vso[task.setvariable variable=qualityGateStatus;isOutput=true]FAILED"
            fi
            
            # Export final results
            echo "##vso[task.setvariable variable=finalPassRate;isOutput=true]$COMBINED_PASS_RATE"
            echo "##vso[task.setvariable variable=totalTests;isOutput=true]$TOTAL_ALL"
            echo "##vso[task.setvariable variable=passedTests;isOutput=true]$PASSED_ALL"
          name: evaluation
          displayName: 'Evaluate Quality Gate'

- stage: Build
  displayName: 'Build & Push Docker Image'
  dependsOn: Test
  condition: and(succeeded(), eq(dependencies.Test.outputs['TestEvaluation.evaluation.shouldDeploy'], 'true'))
  variables:
    finalPassRate: $[ stageDependencies.Test.TestEvaluation.outputs['evaluation.finalPassRate'] ]
    totalTests: $[ stageDependencies.Test.TestEvaluation.outputs['evaluation.totalTests'] ]
    passedTests: $[ stageDependencies.Test.TestEvaluation.outputs['evaluation.passedTests'] ]
  jobs:
    - job: BuildAndPush
      displayName: 'Build Docker Image & Push to ACR'
      steps:
        - script: |
            echo "=== QUALITY GATE SUMMARY ==="
            echo "âœ… Tests Passed: $(passedTests)/$(totalTests) ($(finalPassRate)%)"
            echo "âœ… Quality Gate: PASSED"
            echo "ðŸš€ Proceeding with Docker build..."
          displayName: 'Quality Gate Summary'

        # Use Azure CLI to build and push (works with Azure RM connection)
        - task: AzureCLI@2
          displayName: 'Build & Push Docker Image to ACR'
          inputs:
            azureSubscription: 'Disprz_QA_Deployment'  # Your existing Azure RM connection
            scriptType: 'bash'
            scriptLocation: 'inlineScript'
            inlineScript: |
              echo "=== BUILDING & PUSHING DOCKER IMAGE ==="
              
              # Login to ACR using Azure CLI
              az acr login --name acrqamicroservices
              
              # Build the Docker image
              echo "ðŸ”¨ Building Docker image..."
              docker build -t $(containerRegistry)/$(imageRepository):$(imageTag) -f $(dockerfilePath) .
              
              # Tag with additional tags
              docker tag $(containerRegistry)/$(imageRepository):$(imageTag) $(containerRegistry)/$(imageRepository):v1.0
              docker tag $(containerRegistry)/$(imageRepository):$(imageTag) $(containerRegistry)/$(imageRepository):latest
              
              # Push all tags
              echo "ðŸ“¤ Pushing to ACR..."
              docker push $(containerRegistry)/$(imageRepository):$(imageTag)
              docker push $(containerRegistry)/$(imageRepository):v1.0
              docker push $(containerRegistry)/$(imageRepository):latest
              
              echo "âœ… Docker build and push completed successfully!"
              echo "ðŸ³ Images pushed:"
              echo "   - $(containerRegistry)/$(imageRepository):$(imageTag)"
              echo "   - $(containerRegistry)/$(imageRepository):v1.0"
              echo "   - $(containerRegistry)/$(imageRepository):latest"

        - script: |
            echo "=== DOCKER BUILD & PUSH SUCCESS ==="
            echo "âœ… Image built successfully"
            echo "âœ… Pushed to ACR: $(containerRegistry)"
            echo ""
            echo "ðŸ³ Image Details:"
            echo "   Registry: $(containerRegistry)"
            echo "   Repository: $(imageRepository)"
            echo "   Tags: $(imageTag), v1.0, latest"
            echo "   Full Image: $(containerRegistry)/$(imageRepository):$(imageTag)"
            echo ""
            echo "ðŸ“Š Quality Metrics:"
            echo "   Test Pass Rate: $(finalPassRate)%"
            echo "   Total Tests: $(totalTests)"
            echo "   Build ID: $(Build.BuildId)"
          displayName: 'Build Success Summary'

- stage: Deploy
  displayName: 'Deploy to Azure Web App'
  dependsOn: Build
  condition: succeeded()
  jobs:
    - job: DeployToAzure
      displayName: 'Deploy Container to Azure'
      steps:
        - task: AzureCLI@2
          displayName: 'Deploy to Azure Web App using CLI'
          inputs:
            azureSubscription: 'Disprz_QA_Deployment'  # Same Azure RM connection
            scriptType: 'bash'
            scriptLocation: 'inlineScript'
            inlineScript: |
              echo "=== DEPLOYING TO AZURE WEB APP ==="
              
              # Create or update the web app
              az webapp create \
                --name $(webAppName) \
                --resource-group $(resourceGroupName) \
                --plan appsvcpln-datascience-linux-qa \
                --deployment-container-image-name $(containerRegistry)/$(imageRepository):$(imageTag) \
                || echo "Web app might already exist, updating..."
              
              # Configure app settings
              az webapp config appsettings set \
                --name $(webAppName) \
                --resource-group $(resourceGroupName) \
                --settings \
                  ASPNETCORE_ENVIRONMENT=Production \
                  ASPNETCORE_URLS=http://+:80 \
                  WEBSITES_PORT=80 \
                  DOCKER_REGISTRY_SERVER_URL=https://$(containerRegistry) \
                  Jwt__Key="production-jwt-key-that-is-long-enough-for-security-requirements-256-bits" \
                  Jwt__Issuer="CalendarApp" \
                  Jwt__Audience="CalendarAppUsers"
              
              # Update container image
              az webapp config container set \
                --name $(webAppName) \
                --resource-group $(resourceGroupName) \
                --docker-custom-image-name $(containerRegistry)/$(imageRepository):$(imageTag) \
                --docker-registry-server-url https://$(containerRegistry)
              
              echo "âœ… Deployment completed!"
              echo "ðŸŒ App URL: https://$(webAppName).azurewebsites.net"

        - script: |
            echo "=== DEPLOYMENT SUCCESS ==="
            echo "ðŸš€ Calendar App is now live!"
            echo ""
            echo "ðŸŒ Application URL:"
            echo "   https://$(webAppName).azurewebsites.net"
            echo ""
            echo "ðŸ³ Container Details:"
            echo "   Image: $(containerRegistry)/$(imageRepository):$(imageTag)"
            echo "   Registry: Azure Container Registry"
            echo "   Build: $(Build.BuildId)"
            echo ""
            echo "ðŸ“Š Quality Metrics:"
            echo "   âœ… Tests Passed Quality Gate (>$(minPassRate)%)"
            echo "   âœ… Fresh Build from Latest Code"
            echo "   âœ… Production-Ready Container"
            echo ""
            echo "ðŸ“± App Features:"
            echo "   âœ… React Calendar UI"
            echo "   âœ… .NET 7 API Backend"
            echo "   âœ… JWT Authentication"
            echo "   âœ… Containerized Deployment"
            echo "   âœ… Auto-scaling Ready"
            echo ""
            echo "ðŸ”§ Management URLs:"
            echo "   App: https://$(webAppName).azurewebsites.net"
            echo "   API: https://$(webAppName).azurewebsites.net/api"
            echo "   Swagger: https://$(webAppName).azurewebsites.net/swagger"
            echo "   Azure Portal: https://portal.azure.com"
          displayName: 'Deployment Success Summary'
